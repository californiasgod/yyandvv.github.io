<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>送给薇薇和洋洋的心</title>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'ZCOOL KuaiLe', cursive, sans-serif;
        }

        #heartCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            /* 爱心整体与文字同步进行淡入淡出 */
            animation: heart-fade 6s infinite ease-in-out;
        }

        #text-container {
            position: relative;
            z-index: 2;
            animation: bounce 1.5s infinite ease-in-out;
            transform-origin: center bottom;
            width: 30vw;
            height: 10vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .name {
            position: absolute;
            color: #ff69b4;
            font-size: 8vw;
            font-weight: normal;
            text-shadow: 0 0 8px rgba(255, 105, 180, 0.7),
                         0 0 15px rgba(255, 105, 180, 0.5);
            animation-duration: 6s;
            animation-iteration-count: infinite;
        }

        .name-vivi {
            animation-name: crossfade-vivi;
        }

        .name-yangyang {
             animation-name: crossfade-yangyang;
        }

        @keyframes bounce {
            0%, 100% {
                transform: translateY(0) scale(1);
            }
            50% {
                transform: translateY(-10px) scale(1.05);
            }
        }

        @keyframes crossfade-vivi {
            0%, 40% { opacity: 1; }
            50%, 90% { opacity: 0; }
            100% { opacity: 1; }
        }

        @keyframes crossfade-yangyang {
            0%, 40% { opacity: 0; }
            50%, 90% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* 爱心整体的淡入淡出动画 */
        @keyframes heart-fade {
            0%, 40% { opacity: 1; }
            45% { opacity: 0.5; } /* 开始切换时，爱心快速淡出 */
            50%, 90% { opacity: 1; } /* 切换完成后，爱心快速淡入 */
            95% { opacity: 0.5; }
            100% { opacity: 1; }
        }

    </style>
</head>
<body>

    <canvas id="heartCanvas"></canvas>

    <div id="text-container">
        <div class="name name-vivi">薇薇</div>
        <div class="name name-yangyang">洋洋</div>
    </div>

    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');

        let particles = [];
        const heartColor = 'rgb(255, 105, 180)';
        // --- 恢复您喜欢的粒子参数 ---
        const particleCount = 2000;
        const heartScale = 0.6;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            particles = [];
            initParticles();
        }

        function getHeartPoint(angle) {
            const x = 16 * Math.pow(Math.sin(angle), 3);
            const y = -(13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle));
            return { x, y };
        }

        function initParticles() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / 30 * heartScale;

            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const { x, y } = getHeartPoint(angle);

                // 恢复较大的随机偏移，实现“大片感”和“虚化”效果
                const offsetX = (Math.random() - 0.5) * scale * 0.6;
                const offsetY = (Math.random() - 0.5) * scale * 0.6;
                
                const currentX = centerX + x * scale + offsetX;
                const currentY = centerY + y * scale + offsetY;

                particles.push({
                    x: currentX,
                    y: currentY,
                    // 存储粒子最初的生成位置，用于防止过度飘散
                    originX: currentX,
                    originY: currentY,
                    // 恢复您喜欢的粒子大小和速度范围
                    size: Math.random() * 2 + 1,
                    alpha: Math.random() * 0.8 + 0.2,
                    speedX: (Math.random() - 0.5) * 0.5,
                    speedY: (Math.random() - 0.5) * 0.5
                });
            }
        }

        function drawParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];

                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = heartColor;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                ctx.fill();

                p.x += p.speedX;
                p.y += p.speedY;

                // --- 新的形态维持逻辑 ---
                // 计算粒子距离其出生点的距离
                const dist = Math.sqrt(Math.pow(p.x - p.originX, 2) + Math.pow(p.y - p.originY, 2));

                // 如果飘得太远（例如超过10像素），就把它重置回出生点附近
                // 这样既能飘动，又不会无限散开
                if (dist > 50) {
                    p.x = p.originX;
                    p.y = p.originY;
                }
            }
        }

        function animate() {
            drawParticles();
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animate();
    </script>
</body>
</html>