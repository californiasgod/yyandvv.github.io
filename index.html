<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>薇&洋</title>
    
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    
    <style>
        body {
            display: grid;
            place-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #000;
        }
        canvas {
            background-color: #000;
        }
    </style>
</head>
<body>
    <canvas id="heartCanvas"></canvas>

    <script>
        // 定义画布尺寸和中心点，以及爱心颜色
        const CANVAS_WIDTH = 640;
        const CANVAS_HEIGHT = 640;
        const CANVAS_CENTER_X = CANVAS_WIDTH / 2;
        const CANVAS_CENTER_Y = CANVAS_HEIGHT / 2;
        const HEART_COLOR = "#FF69B4"; // 爱心的粉色
        const IMAGE_ENLARGE = 11; // 爱心基础大小的缩放因子

        // 定义动画相关的常量
        const GENERATE_FRAMES = 120; // 粒子动画的预计算帧数
        const ANIMATION_DELAY = 0; 
        
        // --- 文本渐变动画的常量 ---
        const TEXT_NAME_1 = "薇薇";
        const TEXT_NAME_2 = "洋洋";
        const TEXT_CYCLE_FRAMES = 360; // 渐变周期（帧）
        
        // --- 修改：更新字体为 'ZCOOL KuaiLe' ---
        // 我们使用 72px 大小，并指定 'cursive' 作为备用字体
        const TEXT_FONT = 'normal 54px "ZCOOL KuaiLe", cursive'; 
        
        const TEXT_COLOR_BASE = "255, 255, 255"; // 白色
        // --- 结束修改 ---


        // --- 帮助函数：替代 Python 的 random 库 ---
        
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        function randomUniform(min, max) {
            return Math.random() * (max - min) + min;
        }
        
        function randomChoice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // --- 核心数学函数：爱心形状和动画逻辑 ---

        function heart_function(t, shrink_ratio = IMAGE_ENLARGE) {
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = -(15 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
            
            x *= shrink_ratio;
            y *= shrink_ratio;
            
            x += CANVAS_CENTER_X;
            y += CANVAS_CENTER_Y;
            
            return [Math.floor(x), Math.floor(y)];
        }

        function scatter_inside(x, y, beta = 0.15) {
            let ratio_x = -beta * Math.log(Math.random());
            let ratio_y = -beta * Math.log(Math.random());
            let dx = ratio_x * (x - CANVAS_CENTER_X);
            let dy = ratio_y * (y - CANVAS_CENTER_Y);
            return [x - dx, y - dy];
        }

        function shrink(x, y, ratio) {
            let distance_sq = Math.pow(x - CANVAS_CENTER_X, 2) + Math.pow(y - CANVAS_CENTER_Y, 2);
            let force = -1 / Math.pow(distance_sq, 0.6);
            let dx = ratio * force * (x - CANVAS_CENTER_X);
            let dy = ratio * force * (y - CANVAS_CENTER_Y);
            return [x - dx, y - dy];
        }

        function curve(p) {
            return 1.0 + 0.5 * Math.sin(p * Math.PI);
        }

        function calc_position(x, y, ratio) {
            let distance_sq = Math.pow(x - CANVAS_CENTER_X, 2) + Math.pow(y - CANVAS_CENTER_Y, 2);
            let force = 1 / Math.pow(distance_sq, 0.520);
            let dx = ratio * force * (x - CANVAS_CENTER_X) + randomInt(-1, 1);
            let dy = ratio * force * (y - CANVAS_CENTER_Y) + randomInt(-1, 1);
            return [x - dx, y - dy];
        }
        
        // --- 绘制渐变文本的函数 ---
        function drawFadingText(ctx, frame) {
            // 1. 计算当前在渐变周期中的进度 (0.0 到 1.0)
            let progress = (frame % TEXT_CYCLE_FRAMES) / TEXT_CYCLE_FRAMES;

            // 2. 使用余弦函数来计算透明度的平滑过渡
            let opacity1 = (Math.cos(progress * 2 * Math.PI) + 1) / 2;
            let opacity2 = 1 - opacity1; // 名字2的透明度与名字1相反

            // 3. 设置文本样式（居中、艺术字体）
            ctx.font = TEXT_FONT; // 这里会使用新加载的字体
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // 4. 添加阴影以增加艺术感
            ctx.shadowColor = 'rgba(255, 105, 180, 0.7)'; // 粉色阴影
            ctx.shadowBlur = 10;

            // 5. 绘制第一个名字 (例如 "薇薇")
            ctx.fillStyle = `rgba(${TEXT_COLOR_BASE}, ${opacity1})`;
            ctx.fillText(TEXT_NAME_1, CANVAS_CENTER_X, CANVAS_CENTER_Y);

            // 6. 绘制第二个名字 (例如 "洋洋")
            ctx.fillStyle = `rgba(${TEXT_COLOR_BASE}, ${opacity2})`;
            ctx.fillText(TEXT_NAME_2, CANVAS_CENTER_X, CANVAS_CENTER_Y);
            
            // 7. 重置阴影，防止它影响后续的粒子绘制
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }


        // --- Heart 类：封装爱心动画的所有逻辑 ---
        class Heart {
            constructor(generate_frame = GENERATE_FRAMES) {
                this.generate_frame = generate_frame;
                this._points = new Set(); 
                this._edge_diffusion_points = new Set();
                this.center_diffusion_points = new Set();
                this.all_points = {};
                
                this.build(2000); 
                
                console.log("开始预计算帧...");
                for (let frame = 0; frame < this.generate_frame; frame++) {
                    this.calc(frame);
                }
                console.log("帧计算完毕。");
            }

            build(number) {
                for (let i = 0; i < number; i++) {
                    let t = randomUniform(0, 2 * Math.PI); 
                    let [x, y] = heart_function(t);
                    this._points.add(JSON.stringify([x, y]));
                }

                for (let pointStr of this._points) {
                    let [x, y] = JSON.parse(pointStr);
                    for (let i = 0; i < 3; i++) {
                        let [nx, ny] = scatter_inside(x, y, 0.05);
                        this._edge_diffusion_points.add(JSON.stringify([nx, ny]));
                    }
                }

                let point_list = Array.from(this._points).map(s => JSON.parse(s));
                for (let i = 0; i < 5000; i++) { 
                    let [x, y] = randomChoice(point_list);
                    let [nx, ny] = scatter_inside(x, y, 0.17);
                    this.center_diffusion_points.add(JSON.stringify([nx, ny]));
                }
            }

            calc(generate_frame) {
                const animation_progress = generate_frame / this.generate_frame;
                const heart_beat_factor = curve(animation_progress * 2); 
                let ratio = 15 * heart_beat_factor;
                let halo_radius = Math.floor(6 + 8 * heart_beat_factor);
                let halo_number = Math.floor(2000 + 3000 * Math.pow(heart_beat_factor, 2));
                
                let all_points_frame = []; 
                let heart_halo_point = new Set();

                for (let i = 0; i < halo_number; i++) {
                    let t = randomUniform(0, 2 * Math.PI);
                    let [x, y] = heart_function(t, 11.6); 
                    [x, y] = shrink(x, y, halo_radius);
                    
                    let key = JSON.stringify([x, y]);
                    if (!heart_halo_point.has(key)) {
                        heart_halo_point.add(key);
                        let t_x = x + randomInt(-14, 14);
                        let t_y = y + randomInt(-14, 14);
                        let size = randomChoice([1, 2, 2]);
                        all_points_frame.push([t_x, t_y, size]);
                    }
                }

                for (let pointStr of this._points) {
                    let [x, y] = JSON.parse(pointStr);
                    [x, y] = calc_position(x, y, ratio);
                    let size = randomInt(1, 3);
                    all_points_frame.push([x, y, size]);
                }

                for (let pointStr of this._edge_diffusion_points) {
                    let [x, y] = JSON.parse(pointStr);
                    [x, y] = calc_position(x, y, ratio);
                    let size = randomInt(1, 2);
                    all_points_frame.push([x, y, size]);
                }

                for (let pointStr of this.center_diffusion_points) {
                    let [x, y] = JSON.parse(pointStr);
                    [x, y] = calc_position(x, y, ratio);
                    let size = randomInt(1, 2);
                    all_points_frame.push([x, y, size]);
                }
                
                this.all_points[generate_frame] = all_points_frame; 
            }

            render(ctx, render_frame) {
                let frame_points = this.all_points[render_frame % this.generate_frame];
                
                ctx.fillStyle = HEART_COLOR;
                for (let point of frame_points) {
                    let [x, y, size] = point;
                    ctx.fillRect(x, y, size, size);
                }
            }
        }

        // --- 主程序：初始化和动画循环 ---
        
        const canvas = document.getElementById('heartCanvas');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        const ctx = canvas.getContext('2d');

        const heart = new Heart(GENERATE_FRAMES); 
        
        let current_render_frame = 0;

        function animationLoop() {
            // 1. 清除画布
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // 2. 渲染爱心
            heart.render(ctx, current_render_frame);
            
            // 3. 渲染渐变文本
            drawFadingText(ctx, current_render_frame);
            
            // 4. 准备下一帧
            current_render_frame++;
            
            // 5. 请求下一帧动画
            requestAnimationFrame(animationLoop);
        }

        // 启动动画
        animationLoop();

    </script>
</body>
</html>